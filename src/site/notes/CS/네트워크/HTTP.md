---
{"dg-publish":true,"permalink":"/cs//http/","dgPassFrontmatter":true,"noteIcon":""}
---

#네트워크

## HTTP(Hyper Text Transfer Protocol)란?

- ==웹에서 데이터를 주고 받기 위한 통신 프로토콜==
	- 웹에만 해당되나? ❌
		- 데이터 송수신이 필요한 곳이라면 웹 이외의 환경에서도 사용됨 
			- 웹 브라우저와 서버 간의 통신
			- API 통신 (RESTful API) 등 등 
- 서버/클라이언트 모델을 따름
- 발전단계는?
	- 1. HTTP/1.0 (1991)
	- 2. HTTP/1.1 (1997)
	- 3. HTTP/2 (2015)


### 특징
- Stateless (무상태성)
	- 이전에 같은 요청을 한 브라우저인지 서버는 알 수 없음
	- 클라이언트와 관련된 데이터를 저장하지 않음 
	- 🧐 클라이언트의 정보를 기억하고 싶다면?  🍪 쿠키나 🔑세션을 사용해야 함


- Connectionless (비연결성)
	- 한 번의 요청-응답 이후에 연결을 끊는 방식
	- 🙎 클라이언트 요청 -> 🖥️ 서버 응답 -> 🙎 요청 받음 -> ❌연결 종료
	- 장점
		- 연결을 유지하는 대신 더 많은 클라이언트의 요청을 빠르게 처리할 수 있어서 **네트워크를 효율적으로 사용할 수 있음**
	- 단점 
		- 매 요청마다 새롭게 연결을 설정하고 끊는 작업이 반복되기 때문에 **연결과 해제에 따른 오버헤드가 발생**





## HTTP/2란?
- **HTTP/1.1의 성능 개선**을 목표로 2015년에 도입된 최신 HTTP 프로토콜
- 더 빠르고 효율적인 데이터 전송을 가능하게 하여 웹 페이지 로딩 속도와 사용자 경험을 크게 향상시킴
- ==구글의 SPDY 프로토콜==을 기반으로 개발됨


### HTTP/2와 HTTP/1.1의 차이점

| 특징     | HTTP/1.1                  | HTTP/2                          |
| ------ | ------------------------- | ------------------------------- |
| 다중화 지원 | 하나의 연결에서 하나의 요청-응답만 처리 가능 | 하나의 연결에서 여러 요청과 응답을 동시에 처리      |
| 헤더 전송  | 각 요청마다 전체 헤더 전송, 중복이 많음   | HPACK으로 헤더 압축, 중복 헤더 생략 가능      |
| 서버 푸시  | 클라이언트 요청 시에만 리소스 전송       | 클라이언트 요청 전에도 필요한 리소스를 서버가 미리 전송 |
| 우선순위   | 리소스 로딩 순서를 지정하기 어려움       | 리소스 요청에 우선순위 지정 가능              |
| 데이터 형식 | 텍스트 기반                    | 이진 프레임 기반                       |


## HTTPS(Hypertext Transfer Protocol Secure)란?
- ==HTTP의 암호화 버전==
- HTTP 위에 **SSL (Secure Sockets Layer)** 또는 **TLS (Transport Layer Security)** 프로토콜을 추가하여 **암호화된 통신**을 제공함
	- TLS는 SSL의 후속 버전으로, <u>현재 대부분의 HTTPS 통신에서는 TLS가 사용됨</u>
- 평문 데이터가 뭐죠? => 암호화되지 않은 거 

### HTTPS 통신의 주요 과정

1. 클라이언트가 HTTPS 연결을 요청 🙋‍♀️
    
    - 클라이언트가 서버와 HTTPS 연결을 시작하면, 브라우저는 HTTPS 포트 (기본적으로 443번)를 통해 서버에 연결을 요청합니다.
2. 서버가 SSL/TLS 인증서를 클라이언트에 전송 📄
    
    - 서버는 자신이 신뢰할 수 있는 서버임을 증명하기 위해 **SSL/TLS 인증서**를 클라이언트에 보냅니다. 이 인증서는 일반적으로 **공인 인증 기관(CA)** 에 의해 발급됩니다.
    - 인증서에는 서버의 공개 키, 인증서의 발급 기관 정보, 유효 기간 등이 포함되어 있습니다.
3. 클라이언트가 인증서를 검증
    
    - 클라이언트는 인증서를 확인하여 서버의 신뢰성을 확인합니다. 클라이언트가 인증서를 신뢰할 수 있는 CA가 발급한 것임을 확인하면, 이 인증서를 통해 서버의 공개 키를 얻습니다.
    - 만약 인증서가 신뢰할 수 없는 경우, 클라이언트는 경고를 표시하고 연결을 종료할 수 있습니다.
4. 세션 키 생성 및 전송 (대칭키 암호화 시작)
    
    - 클라이언트는 ==대칭키==를 생성하여, 이 대칭키를 사용해 데이터를 암호화할 것입니다. 클라이언트는 생성된 대칭키를 **서버의 공개 키**로 암호화하여 서버로 전송합니다.
	    - ❓대칭키란 : <u>암호화와 복호화에 같은 키를 사용</u>하는 암호화 방식
    - 서버는 자신의 **개인 키**로 암호화된 대칭키를 복호화하여 이를 얻습니다.
    - 한 번 생성된 대칭키는, 세션이 유지되는 동안 계속 사용됨
5. 암호화된 데이터 통신 (HTTPS 통신 시작)
    
    - 서버와 클라이언트는 대칭키를 공유하게 되며, 이제부터는 이 대칭키를 이용해 **대칭 암호화 방식**으로 데이터를 암호화하여 통신을 진행합니다.
    - 대칭키 암호화는 처리 속도가 빠르기 때문에 이후의 데이터 전송이 효율적이고 안전하게 이루어집니다.
    
6. 데이터 전송 완료 후 연결 종료
    
    - 클라이언트와 서버는 데이터 전송이 완료되면 연결을 종료하고 대칭키도 폐기합니다. 이로써 이전 통신의 보안이 유지됩니다.ㄷ




### 👩‍💻 -> 🖥️ 🔐

1. **클라이언트가 비밀키(대칭키)를 생성**하고, 이 키를 자신이 가지고 있습니다.
2. **클라이언트는 서버의 공개 자물쇠(공개 키)를 사용해 비밀키를 잠급니다**.
    - 이 공개 자물쇠(공개 키)는 누구나 사용할 수 있지만, 잠긴 비밀키는 **서버의 개인키로만 열 수 있습니다**.
3. **서버는 클라이언트가 보낸 잠긴 비밀키를 자신의 개인키로 풀어서 비밀키를 얻습니다**.
4. 이제 서버와 클라이언트는 **같은 비밀키(대칭키)를 공유**하게 되어, 이 비밀키로 안전하게 통신을 할 수 있습니다.


#### 🌐 통신 과정 예시

1. **클라이언트에서 서버로 데이터 전송**
    
    - 클라이언트가 서버로 보내려는 데이터를 **대칭키로 암호화**합니다.
    - 암호화된 데이터를 서버로 전송합니다.
    - 서버는 **같은 대칭키를 사용해 데이터를 복호화**하여, 원래의 내용을 읽습니다.
2. **서버에서 클라이언트로 데이터 전송**
    
    - 서버가 클라이언트로 보내려는 데이터를 **같은 대칭키로 암호화**합니다.
    - 암호화된 데이터를 클라이언트로 전송합니다.
    - 클라이언트는 **자신이 가진 동일한 대칭키를 사용해 복호화**하여 데이터를 읽습니다.