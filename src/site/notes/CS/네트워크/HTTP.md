---
{"dg-publish":true,"permalink":"/cs//http/","dgPassFrontmatter":true,"noteIcon":"","created":"2024-10-31T11:23:59.275+09:00","updated":"2024-10-31T12:18:49.069+09:00"}
---


## HTTP(Hyper Text Transfer Protocol)란?

- ==데이터를 주고 받기 위한 프로토콜==
	- 웹에만 해당되나? ❌
		- 데이터 송수신이 필요한 곳이라면 웹 이외의 환경에서도 사용됨 
			- 웹 브라우저와 서버 간의 통신
			- API 통신 (RESTful API) 등 등 
- 서버/클라이언트 모델을 따름
- 발전단계는?
	- 1. HTTP/1.0 (1991)
	- 2. HTTP/1.1 (1997)
	- 3. HTTP/2 (2015)


### 특징
- Stateless (무상태성)
	- 이전에 같은 요청을 한 브라우저인지 서버는 알 수 없음
	- 클라이언트와 관련된 데이터를 저장하지 않음 
	- 🧐 클라이언트의 정보를 기억하고 싶다면?  🍪 쿠키나 🔑세션을 사용해야 함

- Connectionless (비연결성)
	- 한 번의 요청-응답 이후에 연결을 끊는 방식
	- 🙎 클라이언트 요청 -> 🖥️ 서버 응답 -> 🙎 요청 받음 -> ❌연결 종료
	- 장점
		- 연결을 유지하는 대신 더 많은 클라이언트의 요청을 빠르게 처리할 수 있어서 **네트워크를 효율적으로 사용할 수 있음**
	- 단점 
		- 매 요청마다 새롭게 연결을 설정하고 끊는 작업이 반복되기 때문에 **연결과 해제에 따른 오버헤드가 발생**





## HTTP/2란?
- **HTTP/1.1의 성능 개선**을 목표로 2015년에 도입된 최신 HTTP 프로토콜
- 더 빠르고 효율적인 데이터 전송을 가능하게 하여 웹 페이지 로딩 속도와 사용자 경험을 크게 향상시킴
- ==구글의 SPDY 프로토콜==을 기반으로 개발됨


### HTTP/2와 HTTP/1.1의 차이점

| 특징     | HTTP/1.1                  | HTTP/2                          |
| ------ | ------------------------- | ------------------------------- |
| 다중화 지원 | 하나의 연결에서 하나의 요청-응답만 처리 가능 | 하나의 연결에서 여러 요청과 응답을 동시에 처리      |
| 헤더 전송  | 각 요청마다 전체 헤더 전송, 중복이 많음   | HPACK으로 헤더 압축, 중복 헤더 생략 가능      |
| 서버 푸시  | 클라이언트 요청 시에만 리소스 전송       | 클라이언트 요청 전에도 필요한 리소스를 서버가 미리 전송 |
| 우선순위   | 리소스 로딩 순서를 지정하기 어려움       | 리소스 요청에 우선순위 지정 가능              |
| 데이터 형식 | 텍스트 기반                    | 이진 프레임 기반                       |


## HTTPS(Hypertext Transfer Protocol Secure)란?
- ==HTTP의 암호화 버전==
- HTTP 위에 **SSL (Secure Sockets Layer)** 또는 **TLS (Transport Layer Security)** 프로토콜을 추가하여 **암호화된 통신**을 제공함
- TLS는 SSL의 후속 버전으로, <u>현재 대부분의 HTTPS 통신에서는 TLS가 사용됨</u>

### HTTPS 통신의 주요 과정

1. 클라이언트가 HTTPS 연결을 요청 🙋‍♀️
    
    - 클라이언트가 서버와 HTTPS 연결을 시작하면, 브라우저는 HTTPS 포트 (기본적으로 443번)를 통해 서버에 연결을 요청합니다.
2. 서버가 SSL/TLS 인증서를 클라이언트에 전송 📄
    
    - 서버는 자신이 신뢰할 수 있는 서버임을 증명하기 위해 **SSL/TLS 인증서**를 클라이언트에 보냅니다. 이 인증서는 일반적으로 **공인 인증 기관(CA)**에 의해 발급됩니다.
    - 인증서에는 서버의 공개 키, 인증서의 발급 기관 정보, 유효 기간 등이 포함되어 있습니다.
3. 클라이언트가 인증서를 검증
    
    - 클라이언트는 인증서를 확인하여 서버의 신뢰성을 확인합니다. 클라이언트가 인증서를 신뢰할 수 있는 CA가 발급한 것임을 확인하면, 이 인증서를 통해 서버의 공개 키를 얻습니다.
    - 만약 인증서가 신뢰할 수 없는 경우, 클라이언트는 경고를 표시하고 연결을 종료할 수 있습니다.
4. 세션 키 생성 및 전송 (대칭키 암호화 시작)
    
    - 클라이언트는 ==대칭키==를 생성하여, 이 대칭키를 사용해 데이터를 암호화할 것입니다. 클라이언트는 생성된 대칭키를 **서버의 공개 키**로 암호화하여 서버로 전송합니다.
	    - ❓대칭키란 : <u>암호화와 복호화에 같은 키를 사용</u>하는 암호화 방식
    - 서버는 자신의 **개인 키**로 암호화된 대칭키를 복호화하여 이를 얻습니다.
    - 한 번 생성된 대칭키는, 세션이 유지되는 동안 계속 사용됨
5. 암호화된 데이터 통신 (HTTPS 통신 시작)
    
    - 서버와 클라이언트는 대칭키를 공유하게 되며, 이제부터는 이 대칭키를 이용해 **대칭 암호화 방식**으로 데이터를 암호화하여 통신을 진행합니다.
    - 대칭키 암호화는 처리 속도가 빠르기 때문에 이후의 데이터 전송이 효율적이고 안전하게 이루어집니다.
    
6. 데이터 전송 완료 후 연결 종료
    
    - 클라이언트와 서버는 데이터 전송이 완료되면 연결을 종료하고 대칭키도 폐기합니다. 이로써 이전 통신의 보안이 유지됩니다.